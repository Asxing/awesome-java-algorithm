
## 十个数据结构

### 01、数组

| 概念与特性   | 1.数组是线性表，用一组连续的内存存储一组具有相同类型的数据；<br />2.最大的特性是支持按照下标O(1)时间复杂度内快速访问数组元素；<br />3.一组数组寻址公式：a[i]_addr = base_addr + i * data_type_size; |
| ------------ | ------------------------------------------------------------ |
| 操作与复杂度 | 1.随机访问时间复杂度O(1)；<br />2.在数组中任意位置插入数据的时间复杂度是O(n)；<br />3.删除数组中任意位置数据的时间复杂度是O(n)； |
| 应用场景     | 数组是其他数据结构和算法的实现基础，⽐如栈、队列、堆、⼆分查找等 |
| 其他知识点   | 1. 数组需要连续的内存空间，对内存的要求较⾼；<br />2. 数组中的数据连续存储，对CPU缓存友好； <br />3. ⼤部分编程语⾔中，数组下标都是从0开始编号； <br />4. ⼤部分编程语⾔中，都提供了容器类型以⽀持动态数组（动态扩容）； <br />5. 编程语⾔中的数组类型并不等同于数据结构中讲的数组； |
| 掌握程度     | 1.实现一个支持动态扩容的数组<br />2.实现一个大小固定的有序数组，支持动态增删改操作<br />3.实现两个有序数组合并为一个有序数组 |
| leet-code    | 88. 合并两个有序数组[👈](https://leetcode-cn.com/problems/merge-sorted-array/) \| [👉]()<br /> |

### 02、链表

| 概念与特性   | 1. 链表是线性表，不需要连续的内存空间来存储元素，通过指针将串联每 个链表中的结点； <br />2. 常⽤的链表结构有：单链表、双向链表、循环链表，其中双向链表因为 ⽀持在O(1)时间复杂度内找到前驱结点，在实际开发中最常⽤； |
| ------------ | ------------------------------------------------------------ |
| 操作与复杂度 | 1. 跟数组对⽐，查找第i个元素的时间复杂度是O(n)； <br />2. 在已知前驱结点的情况下，单链表中插⼊数据的时间复杂度是O(1)； <br />3. 在已知前驱结点的情况下，单链表中删除数据的时间复杂度是O(1)；<br /><br />注意：上⾯的插⼊、删除操作，都是针对已知前驱结点的情况，如果未知 前驱结点，在单链表中插⼊、删除数据时间复杂度是O(n)，⽽在双向链表 中插⼊、删除数据的时间复杂度仍然是O(1)。这也是双向链表⽐单链表更常⽤的主要原因。 |
| 应⽤场景     | 链表是其他数据结构和算法的实现基础，⽐如跳表、散列表等；     |
| 其他知识点   | 1. 链表中的数据不连续存储，对CPU缓存不友好； <br />2. 在实际的编程中，可定义有头链表，也可以定义⽆头链表；有头链表指 的是链表中的头结点不存储数据； |
| 掌握程度     | 1. 熟练实现单链表、双向链表、循环链表的定义和操作；<br />2. 熟练实现经典的链表题⽬，⽐如反转链表、链表求中间结点、合并有序 链表、删除链表倒数第K个结点等； |
| leet-code    |                                                              |

### 03、栈

| 概念与特性   | 1. 栈是⼀种操作受限的线性表，只能在⼀端插⼊删除数据； <br />2. 栈的最⼤特性是先进后出； |
| ------------ | ------------------------------------------------------------ |
| 操作与复杂度 | 1. ⼊栈操作，在栈顶放⼊数据，时间复杂度是O(1)； <br />2. 出栈操作，从栈顶取出数据，时间复杂度是O(1)； |
| 应⽤场景     | 1. 函数调⽤栈； <br />2. 编译器利⽤栈来实现表达式求值； <br />3. 浏览器中的前进后退功能的实现也会⽤到栈； |
| 其他知识点   | 1. 栈既可以⽤数组来实现，也可以⽤链表来实现； <br />2. 基于数组实现的⽀持动态扩容的栈的插⼊操作的均摊时间复杂度是 O(1)； |
| 掌握程度     | 1. 熟练利⽤数组实现⼀个栈； <br />2. 熟练利⽤链表实现⼀个栈； <br />3. 掌握基于数组实现的⽀持动态扩容的栈的插⼊操作的时间复杂度分析； <br />4. ⽤栈检查括号是否匹配，⽐如：`{[()]()[{}]}`或`[{()}([])]`等都为合法格式，⽽ `{[}()]`或`[({)]`为不合法的格式； |
| leet-code    |                                                              |

### 04、队列

| 概念与特性   | 1. 队列是⼀种操作受限的线性表，只能在两端插⼊、删除数据； <br />2. 队列的最⼤特性是先进先出； |
| ------------ | ------------------------------------------------------------ |
| 操作与复杂度 | 1. ⼊队操作，在队尾插⼊数据，时间复杂度是O(1)； <br />2. 出队操作，从队头取出数据，时间复杂度是O(1)； |
| 应⽤场景     | 队列常⽤在有限资源池中，⽤于排队请求，⽐如数据库连接池等；   |
| 其他知识点   | 1. 队列既可以⽤数组来实现，也可以⽤链表来实现； <br />2. 最⻓使⽤的队列是基于数组实现的循环队列； |
| 掌握程度     | 熟练实现⼀个循环队列，重点是掌握队列的判空和判满条件；       |
| leet-code    |                                                              |

### 05、散列表

| 概念与特性   | 函数调⽤函数⾃身的编程⽅式叫做递归，调⽤为”递“，返回为”归“。 |
| ------------ | ------------------------------------------------------------ |
| 操作与复杂度 |                                                              |
| 应⽤场景     |                                                              |
| 其他知识点   |                                                              |
| 掌握程度     |                                                              |
| leet-code    |                                                              |

### 06、二叉树

| 概念与特性   |      |
| ------------ | ---- |
| 操作与复杂度 |      |
| 应⽤场景     |      |
| 其他知识点   |      |
| 掌握程度     |      |
| leet-code    |      |

### 07、堆

| 概念与特性   |      |
| ------------ | ---- |
| 操作与复杂度 |      |
| 应⽤场景     |      |
| 其他知识点   |      |
| 掌握程度     |      |
| leet-code    |      |

### 08、跳表

| 概念与特性   |      |
| ------------ | ---- |
| 操作与复杂度 |      |
| 应⽤场景     |      |
| 其他知识点   |      |
| 掌握程度     |      |
| leet-code    |      |

### 09、图

| 概念与特性   |      |
| ------------ | ---- |
| 操作与复杂度 |      |
| 应⽤场景     |      |
| 其他知识点   |      |
| 掌握程度     |      |
| leet-code    |      |

### 10、Trie树

| 概念与特性   |      |
| ------------ | ---- |
| 操作与复杂度 |      |
| 应⽤场景     |      |
| 其他知识点   |      |
| 掌握程度     |      |
| leet-code    |      |

## 十个算法

### 11、递归

| 概念与特性   |      |
| ------------ | ---- |
| 操作与复杂度 |      |
| 应⽤场景     |      |
| 其他知识点   |      |
| 掌握程度     |      |
| leet-code    |      |

### 12、排序

| 概念与特性   |      |
| ------------ | ---- |
| 操作与复杂度 |      |
| 应⽤场景     |      |
| 其他知识点   |      |
| 掌握程度     |      |
| leet-code    |      |

### 13、二分查找

| 概念与特性   |      |
| ------------ | ---- |
| 操作与复杂度 |      |
| 应⽤场景     |      |
| 其他知识点   |      |
| 掌握程度     |      |
| leet-code    |      |

### 14、搜索

| 概念与特性   |      |
| ------------ | ---- |
| 操作与复杂度 |      |
| 应⽤场景     |      |
| 其他知识点   |      |
| 掌握程度     |      |
| leet-code    |      |

### 15、哈希算法

| 概念与特性   |      |
| ------------ | ---- |
| 操作与复杂度 |      |
| 应⽤场景     |      |
| 其他知识点   |      |
| 掌握程度     |      |
| leet-code    |      |

### 16、贪心算法

| 概念与特性   |      |
| ------------ | ---- |
| 操作与复杂度 |      |
| 应⽤场景     |      |
| 其他知识点   |      |
| 掌握程度     |      |
| leet-code    |      |

### 17、分治算法

| 概念与特性   |      |
| ------------ | ---- |
| 操作与复杂度 |      |
| 应⽤场景     |      |
| 其他知识点   |      |
| 掌握程度     |      |
| leet-code    |      |

### 18、回溯算法

| 概念与特性   |      |
| ------------ | ---- |
| 操作与复杂度 |      |
| 应⽤场景     |      |
| 其他知识点   |      |
| 掌握程度     |      |
| leet-code    |      |

### 19、动态规划

| 概念与特性   |      |
| ------------ | ---- |
| 操作与复杂度 |      |
| 应⽤场景     |      |
| 其他知识点   |      |
| 掌握程度     |      |
| leet-code    |      |

### 20、字符串匹配算法

| 概念与特性   |      |
| ------------ | ---- |
| 操作与复杂度 |      |
| 应⽤场景     |      |
| 其他知识点   |      |
| 掌握程度     |      |
| leet-code    |      |

## 必会小抄

### 数组

- 数组插入元素
  ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125124544.jpg)

- 动态数组扩容
  ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125124552.jpg)

- 两个有序数组合并
  ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125124559.jpg)

### 链表

- 实现单链表、循环链表、双向链表，支持增删操作

- 实现单链表反转
  ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125124608.jpg) 
  ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125124616.jpg)

- 实现两个有序的链表合并为一个有序链表
  ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125124627.jpg)

- 链表检测有环
  ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125124641.jpg)

- 实现求链表的中间结点
  ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125124652.jpg)

- 删除倒数第K个元素
  ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125124659.jpg)

### 栈

- 用数组实现一个顺序栈
  
  ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125124708.jpg)

- 用链表实现一个链式栈 
  ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125124718.jpg)

- 编程模拟实现一个浏览器的前进、后退功能
  ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125124727.jpg)

### 队列

- 用数组实现一个顺序队列
  ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125124737.jpg)

- 用链表实现一个链式队列
  ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125124801.jpg)

- 实现一个循环队列
  ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125124815.jpg)

### 递归

- 编程实现斐波那契数列求值f(n)=f(n-1)+f(n-2) 
  ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125124823.jpg)
  ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125124832.jpg)
- 编程实现求阶乘n!
  
  ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125124845.jpg)

- 编程实现一组数据集合的全排列
  ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125124933.jpg)

### 排序

- 归并排序
  ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125124942.jpg)

- 插入排序
  ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125124957.jpg)

- 冒泡排序
  ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125125006.jpg)

- 选择排序
  ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125125016.jpg)

- 快速排序
  ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125125037.jpg)

- 编程实现O(n)时间复杂度内找到一组数据的第K大元素
  ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125125047.jpg)

### 二分查找

- 实现一个有序数组的二分查找算法
  ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125125055.jpg)

- 查找方程根
  ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125125104.jpg)

- 实现模糊二分查找算法（比如大于等于给定值的第一个元素）

    - 计算下边界
      ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125125112.jpg)

    - 计算上边界
      ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125125128.jpg)

    - 找出第一个大于 x 的数
      ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125125138.jpg)

    - 找出第一个小于 x 的数
      ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125125147.jpg)

### 散列表

- 实现一个基于链表法解决冲突问题的散列表
  ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125125156.jpg)

- 实现一个LRU缓存淘汰算法

    - 基于链表实现
      ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125125202.jpg)

    - 基于数组实现
      ![img](https://cdn.jsdelivr.net/gh/HoldDie/img1/20210125125211.jpg)

### 字符串

- 实现一个字符集，只包含a～z这26个英文字母的Trie树

- 实现朴素的字符串匹配算法

### 二叉树

- 实现一个二叉查找树，并且支持插入、删除、查找操作

- 实现查找二叉查找树中某个节点的后继、前驱节点

- 实现二叉树前、中、后序以及按层遍历

### 堆

- 实现一个小顶堆、大顶堆、优先级队列

- 实现堆排序

- 利用优先级队列合并K个有序数组

- 求一组动态数据集合的最大Top K

### 图

- 实现有向图、无向图、有权图、无权图的邻接矩阵和邻接表表示方法

- 实现图的深度优先搜索、广度优先搜索

- 实现Dijkstra算法、A*算法

- 实现拓扑排序的Kahn算法、DFS算法

### 回溯

- 利用回溯算法求解八皇后问题

- 利用回溯算法求解0-1背包问题

### 分治

- 利用分治算法求一组数据的逆序对个数

### 动态规划

- 0-1背包问题

- 最小路径和

- 编程实现莱文斯坦最短编辑距离

- 编程实现查找两个字符串的最长公共子序列

- 编程实现一个数据序列的最长递增子序列


